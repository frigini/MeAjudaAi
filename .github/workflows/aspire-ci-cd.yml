---
name: MeAjudaAi CI Pipeline

"on":
  push:
    branches: [master, develop]
    paths:
      - 'src/Aspire/**'
      - '.github/workflows/aspire-ci-cd.yml'
  pull_request:
    branches: [master, develop]
    paths:
      - 'src/Aspire/**'
      - '.github/workflows/aspire-ci-cd.yml'

permissions:
  contents: read
  checks: write

env:
  DOTNET_VERSION: '10.0.x'

jobs:
  # Build and test the solution
  build-and-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgis/postgis:16-3.4
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.slnx --force-evaluate

      - name: Build solution
        run: dotnet build MeAjudaAi.slnx --no-restore --configuration Release --verbosity minimal

      - name: Install PostgreSQL client
        run: |
          # Install PostgreSQL client tools for health checks
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Wait for PostgreSQL to be ready
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
        run: |
          echo "üîÑ Waiting for PostgreSQL to be ready..."
          echo "Debug: POSTGRES_USER=$POSTGRES_USER"
          echo "Debug: Checking PostgreSQL availability..."

          counter=1
          max_attempts=30

          while [ $counter -le $max_attempts ]; do
            if pg_isready -h localhost -p 5432 -U "$POSTGRES_USER"; then
              echo "‚úÖ PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($counter/$max_attempts)"
            sleep 2
            counter=$((counter + 1))
          done

          # Check if we exited the loop due to timeout
          if ! pg_isready -h localhost -p 5432 -U "$POSTGRES_USER"; then
            echo "‚ùå PostgreSQL failed to become ready within 60 seconds"
            exit 1
          fi

      - name: Setup PostgreSQL connection
        id: db
        uses: ./.github/actions/setup-postgres-connection
        with:
          postgres-host: localhost
          postgres-port: 5432
          postgres-db: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
          postgres-user: ${{ secrets.POSTGRES_USER || 'postgres' }}
          postgres-password: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}

      - name: Run tests
        env:
          ASPNETCORE_ENVIRONMENT: Testing
          # Database configuration for tests that need it
          MEAJUDAAI_DB_PASS: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          MEAJUDAAI_DB_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          MEAJUDAAI_DB: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
          DB_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          DB_USERNAME: ${{ secrets.POSTGRES_USER || 'postgres' }}
          # Map connection string to .NET configuration using double underscore
          ConnectionStrings__DefaultConnection: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__Users: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__Search: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__meajudaai-db: ${{ steps.db.outputs.connection-string }}
        run: |
          echo "üß™ Running core test suite (excluding E2E)..."
          # Run only Architecture and Integration tests - skip E2E tests for Aspire validation
          dotnet test tests/MeAjudaAi.Architecture.Tests/ --no-build --configuration Release
          dotnet test tests/MeAjudaAi.Integration.Tests/ --no-build --configuration Release
          dotnet test src/Modules/Users/Tests/ --no-build --configuration Release
          echo "‚úÖ Core tests passed successfully"

  # Validate Aspire configuration
  aspire-validation:
    runs-on: ubuntu-latest
    needs: build-and-test
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.slnx --force-evaluate

      - name: Validate Aspire AppHost
        run: |
          cd src/Aspire/MeAjudaAi.AppHost
          dotnet build --configuration Release
          echo "‚úÖ Aspire AppHost builds successfully"

      - name: Generate Aspire manifest (for future deployment)
        env:
          # Set fallback values for manifest generation (dry-run mode)
          DB_PASSWORD: 'manifest-generation'
          MEAJUDAAI_DB_PASS: 'manifest-generation'
          KEYCLOAK_ADMIN_PASSWORD: 'manifest-generation'
          ASPNETCORE_ENVIRONMENT: Testing
        run: |
          cd src/Aspire/MeAjudaAi.AppHost
          # This validates the Aspire configuration without deploying
          dotnet run --project . --publisher manifest \
            --output-path ./aspire-manifest.json --dry-run
          echo "‚úÖ Aspire manifest generated successfully"

  # Code quality and security analysis
  code-analysis:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.slnx --force-evaluate

      - name: Check code formatting
        run: |
          echo "üîç Checking code formatting..."
          # Only check whitespace and style (not SonarQube analyzer warnings)
          dotnet format --verify-no-changes \
            --include whitespace style \
            --verbosity normal \
            MeAjudaAi.slnx \
            2>&1 | tee format-output.txt
          
          # Check if any files were actually formatted (not just warnings)
          if grep -q "Formatted code file" format-output.txt; then
            echo "‚ö†Ô∏è Code formatting issues found."
            echo "Run 'dotnet format --include whitespace style' locally to fix."
            grep "Formatted code file" format-output.txt
            exit 1
          else
            echo "‚úÖ No formatting changes needed"
          fi

      - name: Run vulnerability scan
        run: |
          echo "üîç Scanning for vulnerable packages..."
          dotnet list package --vulnerable --include-transitive
          echo "‚úÖ Vulnerability scan completed"

      - name: Basic code quality checks
        run: |
          echo "üîç Running focused code quality checks..."
          # Check for basic C# issues (quiet mode)
          echo "Checking C# syntax..."
          dotnet build MeAjudaAi.slnx --verbosity quiet --no-restore
          echo "‚úÖ Code quality checks passed"

  # Build validation for individual services (without publishing)
  service-build-validation:
    runs-on: ubuntu-latest
    needs: build-and-test
    strategy:
      matrix:
        service:
          - name: "ApiService"
            path: "src/Bootstrapper/MeAjudaAi.ApiService"
          - name: "Users.API"
            path: "src/Modules/Users/API"
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.slnx --force-evaluate

      - name: Validate ${{ matrix.service.name }} builds for containerization
        run: |
          cd ${{ matrix.service.path }}
          # Test that the service can be published (simulates container build)
          dotnet publish -c Release -o ./publish-output
          echo "‚úÖ ${{ matrix.service.name }} builds successfully for containers"
          # Cleanup
          rm -rf ./publish-output
