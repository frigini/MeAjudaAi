---
name: Pull Request Validation

"on":
  pull_request:
    branches: [master, develop]

permissions:
  contents: read
  pull-requests: write
  checks: write
  statuses: write

env:
  DOTNET_VERSION: '9.0.x'

jobs:
  # Job 1: Code Quality Checks
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Check Database Configuration
        run: |
          echo "üîç Checking database configuration..."
          if [ -z "${{ secrets.POSTGRES_PASSWORD }}" ]; then
            echo "‚ö†Ô∏è  GitHub secrets not configured - using fallback values for testing"
            echo "üí° To configure production secrets, go to: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "   Required secrets: POSTGRES_PASSWORD, POSTGRES_USER, POSTGRES_DB"
          else
            echo "‚úÖ GitHub secrets configured"
          fi

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.sln

      - name: Build solution
        run: dotnet build MeAjudaAi.sln --configuration Release --no-restore

      - name: Wait for PostgreSQL to be ready
        run: |
          echo "üîÑ Waiting for PostgreSQL to be ready..."
          export PGPASSWORD="${{ secrets.POSTGRES_PASSWORD || 'test123' }}"
          for i in {1..30}; do
            if pg_isready -h localhost -p 5432 -U "${{ secrets.POSTGRES_USER || 'postgres' }}"; then
              echo "‚úÖ PostgreSQL is ready!"
              break
            fi
            echo "Waiting for PostgreSQL... ($i/30)"
            sleep 2
          done
          
          # Check if we exited the loop due to timeout
          if ! pg_isready -h localhost -p 5432 -U "${{ secrets.POSTGRES_USER || 'postgres' }}"; then
            echo "‚ùå PostgreSQL failed to become ready within 60 seconds"
            exit 1
          fi

      - name: Run tests with coverage
        env:
          ASPNETCORE_ENVIRONMENT: Testing
          # PostgreSQL connection for CI
          MEAJUDAAI_DB_HOST: localhost
          MEAJUDAAI_DB_PORT: 5432
          MEAJUDAAI_DB_PASS: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          MEAJUDAAI_DB_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          MEAJUDAAI_DB: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
          # Legacy environment variables for compatibility
          DB_HOST: localhost
          DB_PORT: 5432
          DB_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          DB_USERNAME: ${{ secrets.POSTGRES_USER || 'postgres' }}
          DB_NAME: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
          # Keycloak settings
          KEYCLOAK_ADMIN_PASSWORD: ${{ secrets.KEYCLOAK_ADMIN_PASSWORD || 'admin123' }}
          # Connection string format for .NET
          ConnectionStrings__DefaultConnection: >-
            ${{ secrets.DB_CONNECTION_STRING || 'Host=localhost;Port=5432;Database=meajudaai_test;Username=postgres;Password=test123' }}
        run: |
          echo "üß™ Executando testes com cobertura..."

          echo "üèóÔ∏è Executando testes de arquitetura (sem banco)..."
          ARCH="tests/MeAjudaAi.Architecture.Tests/"
          ARCH+="MeAjudaAi.Architecture.Tests.csproj"
          dotnet test "$ARCH" \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./coverage/architecture \
            --logger "trx;LogFileName=architecture-tests.trx"
            
          echo "üîó Executando testes de integra√ß√£o (com banco)..."
          INTEG="tests/MeAjudaAi.Integration.Tests/"
          INTEG+="MeAjudaAi.Integration.Tests.csproj"

          # Test database connection first
          echo "Testing database connection..."
          PGPASSWORD="${{ secrets.POSTGRES_PASSWORD || 'test123' }}" \
            psql -h localhost \
                 -U "${{ secrets.POSTGRES_USER || 'postgres' }}" \
                 -d "${{ secrets.POSTGRES_DB || 'meajudaai_test' }}" \
                 -c "SELECT 1;" || {
            echo "‚ùå Database connection failed"
            echo "Skipping integration tests..."
            echo "‚úÖ Architecture tests completed successfully"
            exit 1
          }

          dotnet test "$INTEG" \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./coverage/integration \
            --logger "trx;LogFileName=integration-tests.trx"

          echo "‚úÖ Testes executados com sucesso"

      - name: Validate namespace reorganization
        run: |
          echo "üîç Validating namespace reorganization..."
          if grep -R -nP '^\s*using\s+MeAjudaAi\.Shared\.Common;' -- src/ \
              2>/dev/null; then
            echo "‚ùå Found old namespace imports"
            exit 1
          else
            echo "‚úÖ Conformidade com namespaces validada"
          fi

      - name: Upload Architecture coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-architecture
          path: coverage/architecture/**
          if-no-files-found: ignore

      - name: Upload Integration coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-integration
          path: coverage/integration/**
          if-no-files-found: ignore

      - name: Upload Test Results (TRX)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-trx
          path: "**/*.trx"
          if-no-files-found: ignore

      - name: Code Coverage Summary
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: coverage/**/coverage.cobertura.xml
          badge: true
          fail_below_min: false
          format: markdown
          hide_branch_rate: false
          hide_complexity: true
          indicators: true
          output: both
          thresholds: '60 80'

      - name: Add Coverage PR Comment
        uses: marocchino/sticky-pull-request-comment@v2
        if: github.event_name == 'pull_request'
        with:
          recreate: true
          path: code-coverage-results.md

  # Job 2: Security Scan (Consolidated)
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore dependencies
        run: dotnet restore MeAjudaAi.sln

      - name: Run Security Audit
        run: dotnet list package --vulnerable --include-transitive

      - name: OSV-Scanner (fail on HIGH/CRITICAL)
        run: |
          echo "üîç Installing OSV-Scanner..."
          # Install OSV-Scanner
          curl -sSfL https://github.com/google/osv-scanner/releases/latest/download/osv-scanner_linux_amd64 -o osv-scanner
          chmod +x osv-scanner
          
          echo "üîç Running vulnerability scan..."
          # Run OSV-Scanner with high/critical severity filter
          ./osv-scanner --lockfile-keep-going --skip-git --format json . > osv-results.json || true
          
          # Check for high/critical vulnerabilities
          if [ -f osv-results.json ]; then
            HIGH_CRIT=$(jq -r '.results[].packages[]?.vulnerabilities[]? | select(.severity == "HIGH" or .severity == "CRITICAL") | .id' osv-results.json 2>/dev/null | wc -l)
            if [ "$HIGH_CRIT" -gt 0 ]; then
              echo "‚ùå Found $HIGH_CRIT HIGH/CRITICAL vulnerabilities!"
              echo "üìÑ Review osv-results.json for details"
              exit 1
            else
              echo "‚úÖ No HIGH/CRITICAL vulnerabilities found"
            fi
          else
            echo "‚ö†Ô∏è OSV scan completed without results file"
          fi

      - name: Upload OSV Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: osv-scan-results
          path: osv-results.json
          if-no-files-found: ignore

      - name: Secret Detection with TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.pull_request.base.ref }}
          head: HEAD
          extra_args: --debug --only-verified

  # Job 3: Markdown Link Validation (Simplified)
  markdown-link-check:
    name: Validate Markdown Links
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Cache lychee results
        uses: actions/cache@v4
        with:
          path: .lycheecache
          key: lychee-${{ runner.os }}-${{ hashFiles('**/*.md','lychee.toml') }}
          restore-keys: |
            lychee-${{ runner.os }}-

      - name: Check markdown links with lychee
        uses: lycheeverse/lychee-action@v1.10.0
        with:
          # Use simplified configuration for reliability
          args: >-
            --config lychee.toml
            --no-progress
            --cache
            --max-cache-age 1d
            "docs/**/*.md"
            "README.md"
          # Don't fail the entire pipeline on link check failures
          fail: false
          jobSummary: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Report link check results
        if: always()
        run: |
          echo "üìã Link validation completed (non-blocking)"
          echo "‚ÑπÔ∏è  Check job summary for detailed results"

  # Job 4: Simple YAML Validation (Quiet)
  yaml-validation:
    name: YAML Syntax Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install yamllint
        run: python3 -m pip install --user yamllint

      - name: Validate workflow files only
        run: |
          echo "üîç Validating critical YAML files..."
          if ! yamllint -c .yamllint.yml .github/workflows/; then
            echo "‚ùå YAML validation failed"
            echo "‚ÑπÔ∏è  Check yamllint output above for details"
            exit 1
          fi
          echo "‚úÖ YAML validation completed"
