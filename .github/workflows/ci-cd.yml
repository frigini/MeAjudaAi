---
name: CI/CD Pipeline

"on":
  push:
    branches: [master, develop]
  workflow_dispatch:
    inputs:
      deploy_infrastructure:
        description: 'Deploy infrastructure to dev'
        required: false
        default: true
        type: boolean
      cleanup_after_test:
        description: 'Cleanup dev resources after deployment test'
        required: false
        default: false
        type: boolean

permissions:
  contents: read
  deployments: write
  statuses: write

env:
  DOTNET_VERSION: '10.0.x'
  AZURE_RESOURCE_GROUP_DEV: 'meajudaai-dev'
  AZURE_LOCATION: 'brazilsouth'

jobs:
  # Job 1: Build and Test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgis/postgis:16-3.4
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}
          POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'postgres' }}
          POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: ðŸ”§ Restore dependencies
        run: dotnet restore MeAjudaAi.sln --force-evaluate --locked-mode

      - name: Build solution
        run: dotnet build MeAjudaAi.sln --configuration Release --no-restore

      - name: Setup PostgreSQL connection
        id: db
        uses: ./.github/actions/setup-postgres-connection
        with:
          postgres-host: localhost
          postgres-port: 5432
          postgres-db: ${{ secrets.POSTGRES_DB || 'meajudaai_test' }}
          postgres-user: ${{ secrets.POSTGRES_USER || 'postgres' }}
          postgres-password: ${{ secrets.POSTGRES_PASSWORD || 'test123' }}

      - name: Run tests
        env:
          ASPNETCORE_ENVIRONMENT: Testing
          # Map connection strings to .NET configuration using double underscore
          ConnectionStrings__DefaultConnection: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__Users: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__Search: ${{ steps.db.outputs.connection-string }}
          ConnectionStrings__meajudaai-db: ${{ steps.db.outputs.connection-string }}
        run: |
          echo "ðŸ§ª Executando todos os testes..."

          # Executar testes unitÃ¡rios e de arquitetura
          dotnet test tests/MeAjudaAi.Shared.Tests/MeAjudaAi.Shared.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Shared
          dotnet test tests/MeAjudaAi.Architecture.Tests/MeAjudaAi.Architecture.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Architecture
          # Executar testes de integraÃ§Ã£o
          dotnet test tests/MeAjudaAi.Integration.Tests/MeAjudaAi.Integration.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Integration
          # Executar testes de mÃ³dulos
          echo "ðŸ§ª Executando testes de mÃ³dulos..."
          dotnet test src/Modules/Users/Tests/MeAjudaAi.Modules.Users.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Users
          dotnet test src/Modules/Documents/Tests/MeAjudaAi.Modules.Documents.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Documents
          dotnet test src/Modules/Providers/Tests/MeAjudaAi.Modules.Providers.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/Providers
          dotnet test src/Modules/ServiceCatalogs/Tests/MeAjudaAi.Modules.ServiceCatalogs.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/ServiceCatalogs

          # Executar testes E2E
          echo "ðŸ” Executando testes E2E..."
          dotnet test tests/MeAjudaAi.E2E.Tests/MeAjudaAi.E2E.Tests.csproj \
            --configuration Release --no-build --verbosity normal \
            --collect:"XPlat Code Coverage" --results-directory TestResults/E2E

          echo "âœ… Todos os testes executados com sucesso"

      - name: Install ReportGenerator
        run: dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: Generate Code Coverage Report
        run: |
          reportgenerator \
            -reports:"TestResults/**/coverage.cobertura.xml" \
            -targetdir:"TestResults/Coverage" \
            -reporttypes:"Html;Cobertura;JsonSummary" \
            -assemblyfilters:"-*.Tests*" \
            -classfilters:"-*.Migrations*;-*OpenApi.Generated*;-*.Metrics.*;-*.HealthChecks.*;-*.Jobs.Hangfire*;-*.Jobs.Configuration*;-*Program*;-*AppHost*;-*.ServiceDefaults*"

      - name: Upload code coverage
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: code-coverage
          path: "TestResults/Coverage/**/*"

      - name: Upload test results
        uses: actions/upload-artifact@v5
        if: always()
        with:
          name: test-results
          path: "**/TestResults/**/*"

  # Job 2: Markdown Link Validation
  markdown-link-check:
    name: Validate Markdown Links
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check markdown links with lychee
        uses: lycheeverse/lychee-action@v1.10.0
        with:
          # Check all markdown files in the repository using config file
          args: --config config/lychee.toml --verbose --no-progress "**/*.md"
          # Fail the job if broken links are found
          fail: true
          # Generate job summary
          jobSummary: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 3: Infrastructure Validation (Optional)
  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    needs: build-and-test
    if: false  # Disabled until Azure credentials are configured

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Validate Bicep templates
        run: |
          az bicep build --file infrastructure/main.bicep
          # Validate Bicep only if the resource group exists
          if az group exists --name ${{ env.AZURE_RESOURCE_GROUP_DEV }} --output tsv | grep true; then
            az deployment group validate \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} \
              --template-file infrastructure/main.bicep \
              --parameters environmentName=dev location=${{ env.AZURE_LOCATION }}
          else
            echo "Resource group '${{ env.AZURE_RESOURCE_GROUP_DEV }}' does not exist, skipping Bicep validation"
          fi

  # Job 4: Deploy to Development (Optional)
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-and-test, validate-infrastructure]
    if: false  # Disabled until Azure credentials and environment are configured
    # environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Create Resource Group
        if: github.event.inputs.deploy_infrastructure == 'true' || github.event.inputs.deploy_infrastructure == ''
        run: |
          az group create \
            --name ${{ env.AZURE_RESOURCE_GROUP_DEV }} \
            --location ${{ env.AZURE_LOCATION }}

      - name: Deploy Infrastructure
        if: github.event.inputs.deploy_infrastructure == 'true' || github.event.inputs.deploy_infrastructure == ''
        run: |
          DEPLOYMENT_NAME="meajudaai-dev-$(date +%s)"
          az deployment group create \
            --name "$DEPLOYMENT_NAME" \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} \
            --template-file infrastructure/main.bicep \
            --parameters environmentName=dev location=${{ env.AZURE_LOCATION }}
          # Export infrastructure outputs for reference
          az deployment group show \
            --name "$DEPLOYMENT_NAME" \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} \
            --query "properties.outputs" > infrastructure-outputs.json
          echo "Infrastructure outputs:"
          cat infrastructure-outputs.json
          # Get connection string for development use
          SERVICE_BUS_NAMESPACE=$(jq -r '.serviceBusNamespace.value' infrastructure-outputs.json)
          MANAGEMENT_POLICY_NAME=$(jq -r '.managementPolicyName.value' infrastructure-outputs.json)
          CONNECTION_STRING=$(az servicebus namespace authorization-rule keys list \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP_DEV }} \
            --namespace-name "$SERVICE_BUS_NAMESPACE" \
            --name "$MANAGEMENT_POLICY_NAME" \
            --query "primaryConnectionString" \
            --output tsv)
          echo "âœ… Infrastructure deployed successfully!"
          echo "ðŸ”— Service Bus Namespace: $SERVICE_BUS_NAMESPACE"
          echo "ðŸ’¡ To use locally, set: export Messaging__ServiceBus__ConnectionString='[CONNECTION_STRING]'"

      - name: Upload infrastructure outputs
        if: github.event.inputs.deploy_infrastructure == 'true' || github.event.inputs.deploy_infrastructure == ''
        uses: actions/upload-artifact@v5
        with:
          name: infrastructure-outputs-dev
          path: infrastructure-outputs.json

      - name: Cleanup after test (if requested)
        if: github.event.inputs.cleanup_after_test == 'true'
        run: |
          echo "ðŸ§¹ Cleaning up dev resources as requested..."
          az group delete --name ${{ env.AZURE_RESOURCE_GROUP_DEV }} --yes --no-wait
          echo "âœ… Cleanup initiated (resources will be deleted in a few minutes)"
