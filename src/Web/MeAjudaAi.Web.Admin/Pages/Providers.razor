@page "/providers"
@attribute [Authorize(Policy = PolicyNames.ProviderManagerPolicy)]
@using MeAjudaAi.Web.Admin.Authorization
@using MeAjudaAi.Web.Admin.Constants.Modules.Providers
@using MeAjudaAi.Web.Admin.Services
@using MeAjudaAi.Web.Admin.Services.Interfaces
@using MeAjudaAi.Web.Admin.Helpers
@inherits FluxorComponent
@inject IState<ProvidersState> ProvidersState
@inject IDispatcher Dispatcher
@inject IDialogService DialogService
@inject ILogger<Providers> Logger
@inject IPermissionService PermissionService
@inject NavigationManager Navigation
@implements IDisposable

<PageTitle>Provedores - MeAjudaAi Admin</PageTitle>

<div class="d-flex justify-space-between align-center mb-4">
    <MudText Typo="Typo.h3">Provedores</MudText>
</div>

@if (ProvidersState.Value.IsLoading)
{
    <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4" />
}

@if (!string.IsNullOrEmpty(ProvidersState.Value.ErrorMessage))
{
    <MudAlert Severity="Severity.Warning" Class="mb-4">
        <MudText Typo="Typo.body1">Nenhum provedor encontrado ou erro ao carregar dados.</MudText>
    </MudAlert>
}

<MudCard>
    <MudCardHeader>
        <CardHeaderContent>
            <MudTextField @bind-Value="_searchTerm"
                          Label="Pesquisar provedores"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.Start"
                          AdornmentIcon="@Icons.Material.Filled.Search"
                          Immediate="true"
                          DebounceInterval="300"
                          OnDebounceIntervalElapsed="OnSearchChanged"
                          Clearable="true"
                          AriaLabel="Pesquisar provedores por nome, email ou documento"
                          Class="mb-4" />
        </CardHeaderContent>
    </MudCardHeader>
    <MudCardContent>
        <MudDataGrid T="ModuleProviderDto" 
                     Items="@_filteredProviders" 
                     ReadOnly="true"
                     Dense="true"
                     Hover="true"
                     Virtualize="true"
                     FixedHeader="true"
                     Height="calc(100vh - 400px)"
                     Loading="@ProvidersState.Value.IsLoading"
                     RowStyleFunc="@_rowStyleFunc">
            <Columns>
                <PropertyColumn Property="x => x.Id" Title="ID" />
                <PropertyColumn Property="x => x.ProviderType" Title="Tipo" />
                <PropertyColumn Property="x => x.Name" Title="Nome" />
                <PropertyColumn Property="x => x.Document" Title="Documento" />
                <PropertyColumn Property="x => x.Email" Title="E-mail" />
                <PropertyColumn Property="x => x.Phone" Title="Telefone" />
                <PropertyColumn Property="x => x.VerificationStatus" Title="Status">
                    <CellTemplate>
                        @{
                            var statusInt = int.TryParse(context.Item.VerificationStatus, out int s) ? s : 0;
                        }
                        <MudChip Color="@VerificationStatus.ToColor(statusInt)" Size="Size.Small">
                            @VerificationStatus.ToDisplayName(statusInt)
                        </MudChip>
                    </CellTemplate>
                </PropertyColumn>
                <TemplateColumn Title="Ações" Sortable="false">
                    <CellTemplate>
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" 
                                       Color="Color.Primary" 
                                       Size="Size.Small" 
                                       OnClick="@(() => OpenEditDialog(context.Item.Id))" 
                                       Title="Editar" 
                                       AriaLabel="@($"Editar provedor {context.Item.Name}")" />
                        <MudIconButton Icon="@Icons.Material.Filled.VerifiedUser" 
                                       Color="Color.Success" 
                                       Size="Size.Small" 
                                       OnClick="@(() => OpenVerifyDialog(context.Item.Id))" 
                                       Title="Verificar" 
                                       AriaLabel="@($"Verificar provedor {context.Item.Name}")"
                                       Disabled="@(context.Item.VerificationStatus == VerificationStatus.Verified.ToString())" />
                        <MudIconButton Icon="@Icons.Material.Filled.Delete" 
                                       Color="Color.Error" 
                                       Size="Size.Small" 
                                       OnClick="@(() => OpenDeleteDialog(context.Item.Id))" 
                                       Title="Excluir" 
                                       AriaLabel="@($"Excluir provedor {context.Item.Name}")"
                                       Disabled="@(ProvidersState.Value.IsDeleting && ProvidersState.Value.DeletingProviderId == context.Item.Id)" />
                    </CellTemplate>
                </TemplateColumn>
            </Columns>
            <NoRecordsContent>
                <MudText>Nenhum provedor cadastrado</MudText>
            </NoRecordsContent>
        </MudDataGrid>
    </MudCardContent>
    <MudCardActions>
        <MudPagination 
            Count="@ProvidersState.Value.TotalPages" 
            Selected="@ProvidersState.Value.CurrentPage"
            SelectedChanged="@OnPageChanged"
            ShowFirstButton="true"
            ShowLastButton="true" />
    </MudCardActions>
</MudCard>



@code {
    private string _searchTerm = string.Empty;
    private IEnumerable<ModuleProviderDto> _filteredProviders = [];
    private bool _showOnlyPending = false;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        
        // Check for query parameter 'filter=pending'
        var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
        var queryParams = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
        
        if (queryParams.TryGetValue("filter", out var filterValue) &&
            filterValue.ToString().Equals("pending", StringComparison.OrdinalIgnoreCase))
        {
            _showOnlyPending = true;
        }

        // Carregar providers ao inicializar
        Dispatcher.Dispatch(new LoadProvidersAction());
        UpdateFilteredProviders();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);
        
        if (!firstRender)
        {
            UpdateFilteredProviders();
        }
    }

    private void OnSearchChanged()
    {
        // Debouncing é tratado pela propriedade DebounceInterval do MudTextField
        UpdateFilteredProviders();
        StateHasChanged();
    }

    private void UpdateFilteredProviders()
    {
        // Usa memoization para cachear resultados filtrados
        // Inclui _showOnlyPending na chave do cache
        var cacheKey = $"providers_filtered_{_searchTerm}_{_showOnlyPending}_{ProvidersState.Value.Providers.Count()}";
        
        _filteredProviders = PerformanceHelper.Memoize(cacheKey, () =>
        {
            var providers = ProvidersState.Value.Providers;

            // Apply pending filter first if active
            if (_showOnlyPending)
            {
                providers = providers.Where(p => 
                    p.VerificationStatus == VerificationStatus.Pending.ToString()).ToList();
            }

            if (string.IsNullOrWhiteSpace(_searchTerm))
            {
                return providers;
            }

            var searchLower = _searchTerm.ToLowerInvariant();
            return providers.Where(p =>
                (p.Name?.Contains(searchLower, StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                (p.Email?.Contains(searchLower, StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                (p.Document?.Contains(searchLower, StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                (p.Phone?.Contains(searchLower, StringComparison.InvariantCultureIgnoreCase) ?? false)
            ).ToList();
        }, TimeSpan.FromSeconds(30));
    }

    private void OnPageChanged(int page)
    {
        Dispatcher.Dispatch(new GoToPageAction(page));
    }
    
    
    // Highlights rows with Pending status (cached delegate to avoid re-renders)
    private readonly Func<ModuleProviderDto, int, string> _rowStyleFunc = (x, i) =>
    {
        if (x.VerificationStatus == VerificationStatus.Pending.ToString())
            return "background-color: var(--mud-palette-warning-hover); font-weight: 500;";
            
        return "";
    };


    private async Task OpenEditDialog(Guid providerId)
    {
        var parameters = new DialogParameters<EditProviderDialog>
        {
            { x => x.ProviderId, providerId }
        };
        
        var dialog = await DialogService.ShowAsync<EditProviderDialog>("Editar Provedor", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            Dispatcher.Dispatch(new LoadProvidersAction());
        }
    }

    private async Task OpenVerifyDialog(Guid providerId)
    {
        var parameters = new DialogParameters<VerifyProviderDialog>
        {
            { x => x.ProviderId, providerId }
        };
        
        var dialog = await DialogService.ShowAsync<VerifyProviderDialog>("Verificar Provedor", parameters);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            Dispatcher.Dispatch(new LoadProvidersAction());
        }
    }

    private async Task OpenDeleteDialog(Guid providerId)
    {
        var result = await DialogService.ShowMessageBox(
            "Confirmar Exclusão",
            "Tem certeza que deseja excluir este provedor? Esta ação não pode ser desfeita.",
            yesText: "Excluir",
            cancelText: "Cancelar");

        if (result == true)
        {
            // Dispatcha ação - Effect irá lidar com a chamada da API
            Dispatcher.Dispatch(new DeleteProviderAction(providerId));
        }
    }

    public void Dispose()
    {
        // Limpa cache de memoization quando componente é descartado
        PerformanceHelper.ClearMemoizationCache();
    }
}
